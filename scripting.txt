Sider 3 Lua Module Programmers Guide
====================================



1. Introduction
~~~~~~~~~~~~~~~

The main idea here is to provide a safe and flexible way to 
expand Sider functionality. It will (eventually) allow modders to
tweak many aspects of the game, load all sorts of extra content
and even do gameplay tweaks. 

Instead of offering a C interface to, where the programmers would need 
to write a DLL, i'm a taking a different approach here and trying to
design a system, where expansion modules are written in Lua. A module
would typically initialize itself by registering for certain events,
and then Sider will call the module functions, when those events
occur later in the game.

Lua is by now a well-established language of choice for scripting 
support in games, used all over the gaming industry. Most famous
example is probably WarCraft.

To boost the performance, Sider uses a just-in-time compiler for Lua 
called LuaJIT, written by Mike Pall. LuaJIT is a trully brilliant piece
of software. It is 100% compatible with Lua 5.1, and also implements
some features of Lua 5.2, but more importantly it is blazingly fast,
often approaching the speed of C code.
(More information here: https://luajit.org)

After reading this guide, the next step is to study the example
modules, which are provided with Sider. If you are famil
Find them in the "modules" directory.



2. Module structure
~~~~~~~~~~~~~~~~~~~

If you are familiar with Lua and how modules are typically organized
then this will make full sense to you. If are you new to Lua, i would
strongly recommend reading "Programming in Lua" by Roberto Ierusalimschy.
2nd edition covers Lua 5.1, which is the version of the language used 
by Sider. However, any other edition of the book will be just as helpful.

In any case, the module organization is pretty simple:

a) Your need to create a new table
b) Provide an "init" function in that table, where you need to 
do any initialization logic for the module and register for the events 
your module is interested in.
c) Return that table as the last statement

Example module:

-----------------------------
local m = {}

function m.init(ctx)
    log("Hello, world!")
end

return m
-----------------------------


As you have already guessed, this module doesn't really do much. But it
is a valid module, and can be loaded by Sider. For that you need to save
it as <something>.lua file in the "modules" folder, inside sider. Let's 
assume that you named it: test.lua. Then, you must also enable it in
sider.ini, like this:

lua.module = "test.lua"

**************************************************************************
**************************************************************************
VERY IMPORTANT: File encoding must be UTF-8. This is vital, if you are
using non-latin characters in the strings in the module code - for example,
in paths. If you only have latin-1 chars, then ANSI is ok too.
**************************************************************************
**************************************************************************

If you now run the game, your module will get loaded by Sider, and then
the "init" function will be called, so you should see a "Hello, world!"
message in sider.log. 

If you made a mistake and your module has a syntax error, for example, 
or some other problem, then you should see an error message in sider.log,
explaining where (on which line of the script) the problem occurred.

Let's now see how you can make a more useful module. First step for that
is to understand the context object (ctx).



3. Context object
~~~~~~~~~~~~~~~~~

Context object is what Sider "knows" about the current state
of the game. As of right now, it only contains the following
fields: home_team, away_team. However, the idea is to eventually
have it provide all sorts of information, such as: tournament id,
stadium info, which ball is being used, and so for. This will 
require some additional investigative work and then building that
into Sider in the future versions. 
For 3.3.0 release, this is what the context object has:

ctx.home_team  - id of the home team of the current match, after
                 it is selected in the exhibition match, or time
                 is advanced in a league mode to the next match.

ctx.away_team  - id of the away team of the current match, after
                 it is selected in the exhibition match, or time
                 is advanced in a league mode to the next match.

ctx.tournament_id  -  only known, after "trophy check" event happens.


The context object also contains a register function, which has the
following signature:

ctx.register(event_name, handler_function)

The event_name parameter is a string, which identifies a particular
event. The handler_function should be a function in your Lua module,
which will be called when the corresponding event happens. Parameters
vary depending on the event - see the next section for details on all
supported events and their handler signatures

The whole of context object is that in your handler functions, your
code will make decisions on what to do, using the information in the
context.



4. Supported events
~~~~~~~~~~~~~~~~~~~


- Event name: "livecpk_make_key"
Handler function: f(ctx, filename)
Return value is expected to be a string or nil.

This event occurs when the game needs to find out some information
about the file, specified by relative filename. Maybe the game needs
to create a buffer, or it needs to determine the filesize, or something
else. Your handler function is expected to return a string key that
will be used for caching of "livecpk_get_filepath". You can just 
return filename as the key, without any changes, or return nil - 
which will result in the same outcome. But sometimes, you need to make 
a different key, because the context has some additional information
that is important. A good example is the trophy-server module (trophy.lua):
it returns a key that has tournament id in it, which allows
it to later load some files for tournament A and other files for 
tournament B.

IMPORTANT: This event can fire a lot of times for a given filename,
so try to avoid doing expensive computations in the handler function, 
because it may affect your frame rate.


- Event name: "livecpk_get_filepath"
Handler function: f(ctx, filename, key)
Return value is expected to be a string or nil.

This event is related to "livecpk_make_key". 
It works like this: after the key is returned by livecpk_make_key
handler, sider needs to know which actual file (absolute path) needs
to be loaded for this key. So your handler function is expected to
return a full absolute filename. Sider will cache this absolute filename
using the key returned by livecpk_make_key, and the next time this file
is needed, the livecpk_get_filepath event will NOT fire. (This is
again done for performance reasons so that we don't unnecessarily seek
the disk). See trophy.lua for an example usage of this event.


- Event name: "livecpk_rewrite"
Handler function: f(ctx, filename)
Return value is expected to be a string or nil. 

Allows the filename to be rewritten to another. This is a very
powerful, but also quite dangerous function, if you are not careful.
If you rewrite the filename to something that does not exist in
LiveCPK roots or in download/data CPKs, then the game will be unable
to load the file, which can lead to different behaviours, depending
on type of file being loaded. If it's a DDS texture, then usually
nothing bad happens - you just get a white texture. But if it is
some sort of model file - you will get an endless loop, where
loading indicator will keep spinning forever, or the game can just
crash. So, be careful, and don't rewrite blindly ;-)

See "kpr2nd.lua" module for an example of rewrite usage: it is
another example of trying to load GK 2nd kit for an away team 
goalkeeper. You will find out that its behaviour is slightly
different from the "keeper2nd.lua" module.


- Event name: "tournament_check_for_trophy"
Handler function: f(ctx, tournament_id)
Return value is expected to be a number.

This event occurs when the game checks the tournament id in order
to decide which entrance scene to use or which trophy celebration
to show at the end of the match. It is a very specific event and
probably is not of much use, other than for the trophy-server module.
However, it does give you the information about current tournament,
and sets the "tournament_id" field in the context object. Ideally, the
tournament id would've been determined earlier, but right now this is
the only way to find out about it.


- Event name: "set_home_team"
Handler function: f(ctx, team_id)
Return value expected: nil

This event fires after the home team is determined - either during
the team selection in exhibition game, or when the time is advanced
to the next match in a league mode (League, Master League, UCL, etc.)
The team id is also set as "home_team" field in the context object
so that it can be used later, if needed.


- Event name: "set_away_team"
Handler function: f(ctx, team_id)
Return value expected: nil

This event fires after the away team is determined - either during
the team selection in exhibition game, or when the time is advanced
to the next match in a league mode (League, Master League, UCL, etc.)
The team id is also set as "away_team" field in the context object
so that it can be used later, if needed.



5. Logging
~~~~~~~~~~

Sider provides a function called "log". This can be used to print
out any information you want into the sider.log file. 
You can use string.format to format your message in a way similar
to what you would do with C printf:

log(string.format("My value is: %0.5f", math.pi))

In sider.log it will appear with a module name prefix, like as:

[<modulename>.lua] My value is: 3.14159



6. Module environment
~~~~~~~~~~~~~~~~~~~~~

Each module runs in its own environment. For detailed explanation
on what an environment is - read about Lua environments in the Lua
manual online, or in Programming in Lua book. What is important
here is that a module has access to a limited set of globals:

Standard Lua: 
    assert, ipairs, pairs, tostring, tonumber, table,
    string, math, _G
Sider: 
    log, _FILE

You can also enable "ffi" and "bit" modules, which are LuaJIT
extensions. By default, they are disabled. To enable, modify your
sider.ini like this:

luajit.ext.enabled = 1

By the way, your module can "investigate" and find out what exactly
is available for it to use - this is not hard, and is left as an
exercise for the reader ;-) Or... you can cheat, and look at env.lua
module.

